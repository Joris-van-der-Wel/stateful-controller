#API Reference for stateful-controller

**Classes**

* [class: Controller](#Controller)
  * [new Controller(context)](#new_Controller)
  * [controller.context](#Controller#context)
  * [controller.currentState](#Controller#currentState)
  * [controller.child](#Controller#child)
  * [controller.parent](#Controller#parent)
  * [controller.state](#Controller#state)
  * [Controller.stateMethodName(prefix, state)](#Controller.stateMethodName)
  * [Controller.statesEqual(stateA, stateB)](#Controller.statesEqual)
  * [Controller.stateListEqual(statesA, statesB)](#Controller.stateListEqual)
  * [controller.enter(state, [upgrade])](#Controller#enter)
  * [controller.leave()](#Controller#leave)
  * [controller.getRootController()](#Controller#getRootController)
  * [controller.getChildrenStateList()](#Controller#getChildrenStateList)
  * [controller.getParentsStateList()](#Controller#getParentsStateList)
  * [controller.getFullStateList([replacementState])](#Controller#getFullStateList)
* [class: DummyController](#DummyController)
  * [new DummyController(context)](#new_DummyController)

**Typedefs**

* [type: ControllerStateObject](#ControllerStateObject)
* [type: ControllerState](#ControllerState)
* [type: ControllerStateList](#ControllerStateList)
* [type: ClientContext](#ClientContext)
 
<a name="Controller"></a>
#class: Controller
**Members**

* [class: Controller](#Controller)
  * [new Controller(context)](#new_Controller)
  * [controller.context](#Controller#context)
  * [controller.currentState](#Controller#currentState)
  * [controller.child](#Controller#child)
  * [controller.parent](#Controller#parent)
  * [controller.state](#Controller#state)
  * [Controller.stateMethodName(prefix, state)](#Controller.stateMethodName)
  * [Controller.statesEqual(stateA, stateB)](#Controller.statesEqual)
  * [Controller.stateListEqual(statesA, statesB)](#Controller.stateListEqual)
  * [controller.enter(state, [upgrade])](#Controller#enter)
  * [controller.leave()](#Controller#leave)
  * [controller.getRootController()](#Controller#getRootController)
  * [controller.getChildrenStateList()](#Controller#getChildrenStateList)
  * [controller.getParentsStateList()](#Controller#getParentsStateList)
  * [controller.getFullStateList([replacementState])](#Controller#getFullStateList)

<a name="new_Controller"></a>
##new Controller(context)
The base class for Controllers.
Implements the stateful controller pattern. Users can inherit from this class to
implement their own stateful controllers. This pattern is useful for implementing
single page web applications, as opposed to a more traditional web application following
the stateless REST architecture.

**Params**

- context <code>[ClientContext](#ClientContext)</code>  

<a name="Controller#context"></a>
##controller.context
**Type**: [ClientContext](#ClientContext)  
<a name="Controller#currentState"></a>
##controller.currentState
**Type**: [ControllerState](#ControllerState)  
<a name="Controller#child"></a>
##controller.child
The current child controller. Setting this attribute also updates the "parent" attribute of the child.

**Type**: [Controller](#Controller)  
<a name="Controller#parent"></a>
##controller.parent
The current parent controller. Setting this attribute also updates the "child" attribute of the parent.

**Type**: [Controller](#Controller)  
<a name="Controller#state"></a>
##controller.state
Assign a chain of states to this controller and its children.
Each controller has 0 or 1 child controllers. When a controller enters a state, it might create a child controller
for that state (by setting the child attribute on its controller).
That child controller is also assigned a state by this method (the next one in the chain).

**Params**

- states <code>[ControllerStateList](#ControllerStateList)</code> - The state chain, or null to leave the state without setting a new one.  
- \[upgrade=false\] `boolean` - <p>If true, the "results" of the given "state" is already present in some form.
          These "results" were generated by a previous state transition in a different execution context. If this
          parameter is "true" you will have to parse the existing "results" and set up any variables, attributes, event
          listeners, etc, so that your controller matches the one in the different execution context.
       </p>
       <p>After this "upgrade", non-upgrade state transitions are able to occur. This means your
          "leave" methods must be able to modify these existing "results" so that the state transition is able to execute
          properly.
       </p>

       <p>The most common use case for upgrades is in a client-server web application. An example:</p>

       <ol>
               <li>The client performs a GET request to "/foo"</li>
               <li>The client & server translate "/foo" to the state ['contentPage', 'foo']</li>
               <li>The server creates a ClientContext including a new DOM Document</li>
               <li>The server creates a: new FrontController(clientContext)</li>
               <li>The server executes frontController.state(['contentPage', 'foo'], false)</li>
               <li>The server serializes the DOM Document as html and sends it to the client as a HTTP response</li>
               <li>The client creates a ClientContext including the DOM Document of the html it received</li>
               <li>The client creates a: new FrontController(clientContext)</li>
               <li>The client executes frontController.state(['contentPage', 'foo'], true)</li>
               <li>The client is now able to execute other state transitions.<br>
                   e.g. frontController.state(['contentPage', 'bar'], false)
               </li>
       </ol>  

**Returns**: `Promise`  
**Example**  
myController.state(['pages', 'contact', 'foo']); // myController is set to the state 'pages',
                                                 // its child controller is set to 'contact', and so on.

<a name="Controller.stateMethodName"></a>
##Controller.stateMethodName(prefix, state)
**Params**

- prefix `string`  
- state <code>[ControllerState](#ControllerState)</code>  

**Returns**: `string`  
**Example**  
Controller.stateMethodName('enter', 'foo') // 'enterFoo'

**Example**  
Controller.stateMethodName('enter', {abc: 5, stateName: 'enterFoo', ...} // 'enterFoo'

<a name="Controller.statesEqual"></a>
##Controller.statesEqual(stateA, stateB)
Are two states equal?.
If both states are a string, case sensitive string matching is used.
If stateA is an object, return <code>stateA.isStateEqual(stateB)</code>

**Params**

- stateA <code>[ControllerState](#ControllerState)</code>  
- stateB <code>[ControllerState](#ControllerState)</code>  

**Returns**: `boolean`  
<a name="Controller.stateListEqual"></a>
##Controller.stateListEqual(statesA, statesB)
Are two states lists equal?.
Each state is matched using Controller.statesEqual

**Params**

- statesA <code>[ControllerStateList](#ControllerStateList)</code>  
- statesB <code>[ControllerStateList](#ControllerStateList)</code>  

**Returns**: `boolean`  
<a name="Controller#enter"></a>
##controller.enter(state, [upgrade])
This method is invoked by .state(...) when the state for this controller should change (leave() is called first).
The default implementation translates the state to a method invocation.
e.g. "foo" -> this.enterFoo()
Override this method if you want to do something else (like pulling the states
out of a database);

**Params**

- state <code>[ControllerState](#ControllerState)</code> - string or an object that describes your state. toString() is called on the object to
       determine the method name to use. {abc: 5, toString: function(){ return 'foo';}, ...} -> this.enterFoo()  
- \[upgrade=false\] `boolean` - Upgrading the results of a state transition in a different execution context? See the
       state() method for more documentation.  

**Type**: `Error`  
**Returns**: `Promise`  
**Access**: protected  
<a name="Controller#leave"></a>
##controller.leave()
This method is invoked by .state(...) when the current state is being left.
The default implementation translates the state to a method invocation.
e.g. "foo" -> this.leaveFoo();
Unlike enter(), this method does not throw if this method does not exist.

**Returns**: `Promise`  
**Access**: protected  
<a name="Controller#getRootController"></a>
##controller.getRootController()
Find the top most Controller by iterating over .parent and return it

**Returns**: [Controller](#Controller)  
<a name="Controller#getChildrenStateList"></a>
##controller.getChildrenStateList()
Return the states all our (grand)children.
Our own child be at index 0, the child of our child at index 1, etc

**Returns**: [ControllerStateList](#ControllerStateList)  
<a name="Controller#getParentsStateList"></a>
##controller.getParentsStateList()
Return the states of all the (grand)parents of this controller.
The top most parent will be at index 0, our own parent at the last index

**Returns**: [ControllerStateList](#ControllerStateList)  
<a name="Controller#getFullStateList"></a>
##controller.getFullStateList([replacementState])
Return the full state list this controller is part of.
This is identical to calling getRootController().getChildrenStateList()

**Params**

- \[replacementState=this.currentState\] <code>[ControllerState](#ControllerState)</code> - If set, replace our own state with this state in the returned list  

**Returns**: [ControllerStateList](#ControllerStateList)  
<a name="DummyController"></a>
#class: DummyController
**Members**

* [class: DummyController](#DummyController)
  * [new DummyController(context)](#new_DummyController)

<a name="new_DummyController"></a>
##new DummyController(context)
A controller that does nothing and accepts a transition to any state.

**Params**

- context <code>[ClientContext](#ClientContext)</code>  

<a name="ControllerStateObject"></a>
#type: ControllerStateObject
An object that describes a state. This object must be immutable (by contract).

**Properties**

- stateName `string` - If a state is an object, this property is used to determine
          the name of the enter method (see Controller.stateMethodName)  
- isStateEqual `function` - If a state is an object, this function must be present.
          It must return true if the first argument is the same state (even if it is not the same instance)  

**Type**: `Object`  
<a name="ControllerState"></a>
#type: ControllerState
You can use either a string or an immutable object to describe a state.

**Type**: `string` | [ControllerStateObject](#ControllerStateObject)  
<a name="ControllerStateList"></a>
#type: ControllerStateList
**Type**: [Array.&lt;ControllerState&gt;](#ControllerState)  
<a name="ClientContext"></a>
#type: ClientContext
**Type**: `Object`  
